
//定义常量 1 #define 宏常量（全局）  2 const修饰的变量(main里面)
//sizeof求数据类型占用内存的大小

// 字符型变量创建char ch='a'；（单引号） 内存1 （sizeof） 引号里面只能有一个字符
// 字符串变量 创建2种方式  1 c风格  2 c++ include<string> string str="hello";
// bool数据类型 1个字节 bool flag=true；输出0或1

// 输出cout<< <<; 输入cin >>变量名;

// 运算符  a++先运算后+   ++a先加后运算
//   &&与   ||或
// 三目运算符  表达式a ? 表达式b :表达式c   若a真则返回b，否则返回c 返回值还可以赋值

//选择结构 switch（） case:   break；  default其他的选项情况
//do while 先执行一次在判断循环条件
//在嵌套循环语句中break退出内循环
//continue执行到本行就不执行后面代码，直接到下一次循环
//goto无条件跳转语句

//随机数 rand（）%100  （生成1~99）
//   随机数种子srand((unsigned int)time(NULL))随机数种子 #include<ctime>

//函数 返回什么就写什么  空值函数--void （）  返回数--int （）返回地址--int *（）

//函数的分文件编写 1创建 .h后缀名的头文件 2 创建 .cpp后缀名的源文件 3在头文件中写函数的声明，在前面还要写框架#include<iostream> using.... 4 在源文件中先写函数的定义 #include “头文件”

//指针字节 8字节（64） 4字节（32）
//空指针 int * p=null 为指针初始化 但不能访问（0~255）内存编号是系统占用的，不可访问
//野指针 指针指向非法的内存空间（自己也不知道里面是什么，不是我们自己申请的）
//const修饰指针（常量指针）：const int *p=&a 指针指向可以改，但是指向的值不可以改
//             （指针常量）：int* const p=&a 指针的指向不可以改，指针指向的只以改
//                  const int*p const p=&a  指针的指向和指向的值都不可以改
//可以通过指针来遍历数组
//数组名就是数组的地址 

//结构体
//结构体数组 stuct 结构体名称 arr[5] 所含此结构体数量
//结构体指针 创建指针变量后通过->来访问结构体成员
//结构体嵌套
//结构体中const  将子函数的形参改为指针，可以减少内存空间（不会复制新的副本）但子函数可能会更改信息，所以用const

//c++中在程序运行前分为全局区和代码区
//代码区  存放函数体的二进制代码  代码区是共享的，只读的（不会被程序修改）
//全局区  全局变量（函数体外的变量） 静态变量（static) 常量（字符串常量属于，const修饰的全局常量属于，const修饰的局部变量不属于） 程序结束后由操作系统释放
//栈区    栈区的数据由编译器开辟和释放  注意不要返回局部变量的地址（局部变量存放在栈区，形参数据也放在栈区，栈区的数据在执行完就自动释放，第一次可以正确显示是因为编译器做了保留，第二次就不会保留）
//堆区    由程序员分配释放，若程序员不释放，在程序结束后系统回收
//        利用new关键字可以将数据开辟（开辟了位置）到堆区    
//        new的语法 int *p=new int（a） new返回的是该数据类型的指针 如果想释放堆区的数据利用关键字 delete，  delete p释放地址（内存）
//        开辟数组 int *arr=new int[10]创建数组，有十个元素--数组名就是数组的地址，所以赋值时，for循环 arr[i]赋值即可  delete[] arr释放数组

//引用（给变量起别名）
// 数据类型 &别名=原名（操作的是同一块地址）
//注意事项：引用必须初始化（必须告诉是谁的别名）   引用一旦初始化后就不可以更改（若b是a的别名，不能在修改b为c的别名
//引用做函数参数（和地址传递一样，但效果更清楚）  void （int &a）则a是main中a的别名，只是名字起的一样
//引用做函数返回值 注意：不要返回局部变量的引用  如果函数的返回值是引用，则函数可以作为左值